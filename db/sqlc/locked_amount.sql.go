// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: locked_amount.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createLockedAmount = `-- name: CreateLockedAmount :one
INSERT INTO locked_amounts (
  sell_req_id,
  buy_req_id,
  locked_total_amount,
  locked_by_card,
  locked_by_cash
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, sell_req_id, buy_req_id, locked_total_amount, locked_by_card, locked_by_cash, created_at, is_released, released_at
`

type CreateLockedAmountParams struct {
	SellReqID         int32       `json:"sell_req_id"`
	BuyReqID          uuid.UUID   `json:"buy_req_id"`
	LockedTotalAmount int64       `json:"locked_total_amount"`
	LockedByCard      pgtype.Int8 `json:"locked_by_card"`
	LockedByCash      pgtype.Int8 `json:"locked_by_cash"`
}

func (q *Queries) CreateLockedAmount(ctx context.Context, arg CreateLockedAmountParams) (LockedAmount, error) {
	row := q.db.QueryRow(ctx, createLockedAmount,
		arg.SellReqID,
		arg.BuyReqID,
		arg.LockedTotalAmount,
		arg.LockedByCard,
		arg.LockedByCash,
	)
	var i LockedAmount
	err := row.Scan(
		&i.ID,
		&i.SellReqID,
		&i.BuyReqID,
		&i.LockedTotalAmount,
		&i.LockedByCard,
		&i.LockedByCash,
		&i.CreatedAt,
		&i.IsReleased,
		&i.ReleasedAt,
	)
	return i, err
}

const getLockedAmount = `-- name: GetLockedAmount :one
SELECT id, sell_req_id, buy_req_id, locked_total_amount, locked_by_card, locked_by_cash, created_at, is_released, released_at FROM locked_amounts
WHERE buy_req_id = $1
`

func (q *Queries) GetLockedAmount(ctx context.Context, buyReqID uuid.UUID) (LockedAmount, error) {
	row := q.db.QueryRow(ctx, getLockedAmount, buyReqID)
	var i LockedAmount
	err := row.Scan(
		&i.ID,
		&i.SellReqID,
		&i.BuyReqID,
		&i.LockedTotalAmount,
		&i.LockedByCard,
		&i.LockedByCash,
		&i.CreatedAt,
		&i.IsReleased,
		&i.ReleasedAt,
	)
	return i, err
}

const getLockedAmountBySellRequest = `-- name: GetLockedAmountBySellRequest :many
SELECT id, sell_req_id, buy_req_id, locked_total_amount, locked_by_card, locked_by_cash, created_at, is_released, released_at FROM locked_amounts
WHERE sell_req_id = $1
AND is_released = false
`

func (q *Queries) GetLockedAmountBySellRequest(ctx context.Context, sellReqID int32) ([]LockedAmount, error) {
	rows, err := q.db.Query(ctx, getLockedAmountBySellRequest, sellReqID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LockedAmount{}
	for rows.Next() {
		var i LockedAmount
		if err := rows.Scan(
			&i.ID,
			&i.SellReqID,
			&i.BuyReqID,
			&i.LockedTotalAmount,
			&i.LockedByCard,
			&i.LockedByCash,
			&i.CreatedAt,
			&i.IsReleased,
			&i.ReleasedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLockedAmounts = `-- name: ListLockedAmounts :many
SELECT id, sell_req_id, buy_req_id, locked_total_amount, locked_by_card, locked_by_cash, created_at, is_released, released_at FROM locked_amounts
WHERE sell_req_id = $1
ORDER BY created_at
LIMIT $2
OFFSET $3
`

type ListLockedAmountsParams struct {
	SellReqID int32 `json:"sell_req_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) ListLockedAmounts(ctx context.Context, arg ListLockedAmountsParams) ([]LockedAmount, error) {
	rows, err := q.db.Query(ctx, listLockedAmounts, arg.SellReqID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LockedAmount{}
	for rows.Next() {
		var i LockedAmount
		if err := rows.Scan(
			&i.ID,
			&i.SellReqID,
			&i.BuyReqID,
			&i.LockedTotalAmount,
			&i.LockedByCard,
			&i.LockedByCash,
			&i.CreatedAt,
			&i.IsReleased,
			&i.ReleasedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const releaseLockedAmountByBuyRequest = `-- name: ReleaseLockedAmountByBuyRequest :exec
UPDATE locked_amounts
SET
  is_released = true,
  released_at = now()
WHERE
  buy_req_id = $1
  AND is_released = false
`

func (q *Queries) ReleaseLockedAmountByBuyRequest(ctx context.Context, buyReqID uuid.UUID) error {
	_, err := q.db.Exec(ctx, releaseLockedAmountByBuyRequest, buyReqID)
	return err
}

const releaseLockedAmountsBySellRequest = `-- name: ReleaseLockedAmountsBySellRequest :exec
UPDATE locked_amounts
SET is_released = true,
    released_at = now()
WHERE sell_req_id = $1 AND is_released = false
`

func (q *Queries) ReleaseLockedAmountsBySellRequest(ctx context.Context, sellReqID int32) error {
	_, err := q.db.Exec(ctx, releaseLockedAmountsBySellRequest, sellReqID)
	return err
}
