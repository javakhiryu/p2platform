// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: spaces.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createSpace = `-- name: CreateSpace :one
INSERT INTO spaces (
    space_id,
    space_name,
    hashed_password,
    description,
    creator_id
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING space_id, space_name, hashed_password, creator_id, description, created_at, updated_at
`

type CreateSpaceParams struct {
	SpaceID        uuid.UUID   `json:"space_id"`
	SpaceName      string      `json:"space_name"`
	HashedPassword string      `json:"hashed_password"`
	Description    string      `json:"description"`
	CreatorID      pgtype.Int8 `json:"creator_id"`
}

func (q *Queries) CreateSpace(ctx context.Context, arg CreateSpaceParams) (Space, error) {
	row := q.db.QueryRow(ctx, createSpace,
		arg.SpaceID,
		arg.SpaceName,
		arg.HashedPassword,
		arg.Description,
		arg.CreatorID,
	)
	var i Space
	err := row.Scan(
		&i.SpaceID,
		&i.SpaceName,
		&i.HashedPassword,
		&i.CreatorID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSpace = `-- name: DeleteSpace :exec
DELETE FROM spaces WHERE space_id = $1
`

func (q *Queries) DeleteSpace(ctx context.Context, spaceID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSpace, spaceID)
	return err
}

const getSpaceByCreatorId = `-- name: GetSpaceByCreatorId :many
SELECT space_id, space_name, hashed_password, creator_id, description, created_at, updated_at FROM spaces WHERE creator_id = $1
`

func (q *Queries) GetSpaceByCreatorId(ctx context.Context, creatorID pgtype.Int8) ([]Space, error) {
	rows, err := q.db.Query(ctx, getSpaceByCreatorId, creatorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Space{}
	for rows.Next() {
		var i Space
		if err := rows.Scan(
			&i.SpaceID,
			&i.SpaceName,
			&i.HashedPassword,
			&i.CreatorID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpaceBySpaceId = `-- name: GetSpaceBySpaceId :one
SELECT space_id, space_name, hashed_password, creator_id, description, created_at, updated_at FROM spaces WHERE space_id = $1
`

func (q *Queries) GetSpaceBySpaceId(ctx context.Context, spaceID uuid.UUID) (Space, error) {
	row := q.db.QueryRow(ctx, getSpaceBySpaceId, spaceID)
	var i Space
	err := row.Scan(
		&i.SpaceID,
		&i.SpaceName,
		&i.HashedPassword,
		&i.CreatorID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listFirstSpacesByNameAsc = `-- name: ListFirstSpacesByNameAsc :many
SELECT space_id, space_name, hashed_password, creator_id, description, created_at, updated_at
FROM spaces
ORDER BY space_name ASC, space_id ASC
LIMIT $1
`

func (q *Queries) ListFirstSpacesByNameAsc(ctx context.Context, limit int32) ([]Space, error) {
	rows, err := q.db.Query(ctx, listFirstSpacesByNameAsc, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Space{}
	for rows.Next() {
		var i Space
		if err := rows.Scan(
			&i.SpaceID,
			&i.SpaceName,
			&i.HashedPassword,
			&i.CreatorID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSpacesAfterCursorByNameAsc = `-- name: ListSpacesAfterCursorByNameAsc :many
SELECT space_id, space_name, hashed_password, creator_id, description, created_at, updated_at
FROM spaces
WHERE (space_name COLLATE "C", space_id) > 
      ($2 COLLATE "C", $3)
ORDER BY space_name COLLATE "C" ASC, space_id ASC
LIMIT $1
`

type ListSpacesAfterCursorByNameAscParams struct {
	Limit     int32  `json:"limit"`
	SpaceName string `json:"space_name"`
	SpaceID   string `json:"space_id"`
}

func (q *Queries) ListSpacesAfterCursorByNameAsc(ctx context.Context, arg ListSpacesAfterCursorByNameAscParams) ([]Space, error) {
	rows, err := q.db.Query(ctx, listSpacesAfterCursorByNameAsc, arg.Limit, arg.SpaceName, arg.SpaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Space{}
	for rows.Next() {
		var i Space
		if err := rows.Scan(
			&i.SpaceID,
			&i.SpaceName,
			&i.HashedPassword,
			&i.CreatorID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSpacesAfterCursorByNameDesc = `-- name: ListSpacesAfterCursorByNameDesc :many
SELECT space_id, space_name, hashed_password, creator_id, description, created_at, updated_at
FROM spaces
WHERE (space_name COLLATE "C", space_id) < 
      ($2 COLLATE "C", $3)
ORDER BY space_name COLLATE "C" ASC, space_id ASC
LIMIT $1
`

type ListSpacesAfterCursorByNameDescParams struct {
	Limit     int32  `json:"limit"`
	SpaceName string `json:"space_name"`
	SpaceID   string `json:"space_id"`
}

func (q *Queries) ListSpacesAfterCursorByNameDesc(ctx context.Context, arg ListSpacesAfterCursorByNameDescParams) ([]Space, error) {
	rows, err := q.db.Query(ctx, listSpacesAfterCursorByNameDesc, arg.Limit, arg.SpaceName, arg.SpaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Space{}
	for rows.Next() {
		var i Space
		if err := rows.Scan(
			&i.SpaceID,
			&i.SpaceName,
			&i.HashedPassword,
			&i.CreatorID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSpaceInfo = `-- name: UpdateSpaceInfo :one
UPDATE spaces
SET
    space_name = COALESCE($1, space_name),
    description = COALESCE($2, description),
    updated_at = CASE
        WHEN $1 IS NOT NULL
          OR $2 IS NOT NULL
        THEN now()
        ELSE updated_at
    END
WHERE space_id = $3
RETURNING space_id, space_name, hashed_password, creator_id, description, created_at, updated_at
`

type UpdateSpaceInfoParams struct {
	SpaceName   pgtype.Text `json:"space_name"`
	Description pgtype.Text `json:"description"`
	SpaceID     uuid.UUID   `json:"space_id"`
}

func (q *Queries) UpdateSpaceInfo(ctx context.Context, arg UpdateSpaceInfoParams) (Space, error) {
	row := q.db.QueryRow(ctx, updateSpaceInfo, arg.SpaceName, arg.Description, arg.SpaceID)
	var i Space
	err := row.Scan(
		&i.SpaceID,
		&i.SpaceName,
		&i.HashedPassword,
		&i.CreatorID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
