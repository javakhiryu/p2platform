name: Deploy to production

on:
  push:
    branches: [main]

jobs:
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create app.env file
        run: |
          cat <<EOF > app.env
          ENVIRONMENT=${{ secrets.ENVIRONMENT }}
          DB_SOURCE=postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@postgres:5432/${{ secrets.DB_NAME }}
          HTTP_SERVER_ADDRESS=0.0.0.0:8080
          KAFKA_BROKERS=kafka:9092
          TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }}
          BASE_URL=${{ secrets.BASE_URL }}
          ACCESS_TOKEN_DURATION=${{ secrets.ACCESS_TOKEN_DURATION }}
          EOF

      - name: Install swag
        run: |
          go install github.com/swaggo/swag/cmd/swag@latest
          go get -u github.com/swaggo/gin-swagger
          go get -u github.com/swaggo/files
          echo "$(go env GOPATH)/bin" >> $GITHUB_PATH

      - name: Login to Personal ACR
        uses: aliyun/acr-login@v1
        with:
          login-server: https://crpi-qzh5i8b0hkdo3v4d.ap-southeast-1.personal.cr.aliyuncs.com
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Build and push API image
        run: |
          docker build -t crpi-qzh5i8b0hkdo3v4d.ap-southeast-1.personal.cr.aliyuncs.com/p2platform/api:${{ github.sha }} .
          docker push crpi-qzh5i8b0hkdo3v4d.ap-southeast-1.personal.cr.aliyuncs.com/p2platform/api:${{ github.sha }}

      - name: Deploy to ECS
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.ECS_IP }}
          username: root
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -ex

            # Install Docker
            if ! command -v docker &>/dev/null; then
              apt-get update -qq
              apt-get install -y -qq \
                apt-transport-https \
                ca-certificates \
                curl \
                gnupg2 \
                software-properties-common

              curl -fsSL https://download.docker.com/linux/debian/gpg | apt-key add -
              add-apt-repository \
                "deb [arch=amd64] https://download.docker.com/linux/debian \
                buster \
                stable"

              apt-get update -qq
              apt-get install -y -qq docker-ce docker-ce-cli containerd.io
              systemctl enable docker
              systemctl start docker
            fi

            # Install Docker Compose
            if ! command -v docker-compose &>/dev/null; then
              curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              chmod +x /usr/local/bin/docker-compose
              ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
            fi

            # Login to ACR
            echo "${{ secrets.REGISTRY_PASSWORD }}" | \
              docker login \
                --username "${{ secrets.REGISTRY_USERNAME }}" \
                --password-stdin \
                crpi-qzh5i8b0hkdo3v4d.ap-southeast-1.personal.cr.aliyuncs.com

            # Создаём конфиг Nginx
            mkdir -p nginx/conf.d
            cat > nginx/conf.d/app.conf <<'NGINX_CONF'
            server {
                listen 80;
                server_name ${{ secrets.DOMAIN_NAME }};
                
                location / {
                    return 301 https://$host$request_uri;
                }
            }

            server {
                listen 443 ssl;
                server_name ${{ secrets.DOMAIN_NAME }};
                
                ssl_certificate /etc/letsencrypt/live/${{ secrets.DOMAIN_NAME }}/fullchain.pem;
                ssl_certificate_key /etc/letsencrypt/live/${{ secrets.DOMAIN_NAME }}/privkey.pem;
                
                # SSL настройки
                ssl_protocols TLSv1.2 TLSv1.3;
                ssl_prefer_server_ciphers on;
                ssl_ciphers "EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH";
                ssl_ecdh_curve secp384r1;
                ssl_session_cache shared:SSL:10m;
                ssl_session_tickets off;
                
                # Security headers
                add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload";
                add_header X-Frame-Options DENY;
                add_header X-Content-Type-Options nosniff;
                add_header X-XSS-Protection "1; mode=block";
                
                # Proxy to API
                location / {
                    proxy_pass http://api:8080;
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                }
            }
            NGINX_CONF

            # Create docker-compose.yml
             cat > docker-compose.yml <<'EOF'
            version: '3.8'

            networks:
              p2platform:
                driver: bridge

            volumes:
              db-data:
              kafka-data:
              nginx-certs:

            services:
              postgres:
                image: postgres:17-alpine
                container_name: postgres
                environment:
                  POSTGRES_USER: ${{ secrets.DB_USER }}
                  POSTGRES_PASSWORD: ${{ secrets.DB_PASSWORD }}
                  POSTGRES_DB: ${{ secrets.DB_NAME }}
                ports:
                  - "5432:5432"
                volumes:
                  - db-data:/var/lib/postgresql/data
                networks:
                  - p2platform
                healthcheck:
                  test: ["CMD-SHELL", "pg_isready -U ${{ secrets.DB_USER }} -d ${{ secrets.DB_NAME }}"]
                  interval: 5s
                  timeout: 5s
                  retries: 5

              kafka:
                image: bitnami/kafka:latest
                container_name: kafka
                networks:
                  - p2platform
                environment:
                  - KAFKA_HEAP_OPTS=-Xmx512m -Xms256m
                  - KAFKA_CFG_NODE_ID=0
                  - KAFKA_CFG_PROCESS_ROLES=controller,broker
                  - KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093
                  - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT
                  - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=0@kafka:9093
                  - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER
                ports:
                  - "9092:9092"
                volumes:
                  - kafka-data:/bitnami/kafka
                healthcheck:
                  test: nc -z localhost 9092
                  interval: 10s
                  timeout: 10s
                  retries: 5

              api:
                image: crpi-qzh5i8b0hkdo3v4d.ap-southeast-1.personal.cr.aliyuncs.com/p2platform/api:${{ github.sha }}
                container_name: api
                environment:
                  - DB_SOURCE=postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@postgres:5432/${{ secrets.DB_NAME }}?sslmode=disable
                  - KAFKA_BROKERS=kafka:9092
                depends_on:
                  postgres:
                    condition: service_healthy
                  kafka:
                    condition: service_healthy
                entrypoint: ["/app/wait-for.sh", "postgres:5432", "--", "/app/wait-for.sh", "kafka:9092", "--", "/app/start.sh"]
                command: ["/app/main"]
                networks:
                  - p2platform

              nginx:
                image: nginx:alpine
                container_name: nginx
                ports:
                  - "80:80"
                  - "443:443"
                volumes:
                  - ./nginx/conf.d:/etc/nginx/conf.d
                  - /etc/letsencrypt:/etc/letsencrypt:ro
                depends_on:
                  - api
                networks:
                  - p2platform

              certbot:
                image: certbot/certbot
                container_name: certbot
                volumes:
                  - /etc/letsencrypt:/etc/letsencrypt
                  - ./nginx/conf.d:/etc/nginx/conf.d
                command: certonly --webroot -w /var/www/html -d ${{ secrets.DOMAIN_NAME }} --email ${{ secrets.ADMIN_EMAIL }} --agree-tos --non-interactive --keep-until-expiring
                depends_on:
                  - nginx
                networks:
                  - p2platform
            EOF

            # Deploy services
            docker-compose up nginx
            sleep 10  # Ждём запуска Nginx
            docker-compose up certbot
            
            # Полный запуск всех сервисов
            docker-compose down
            docker-compose up

             # Настройка cron для автоматического обновления сертификатов
            (crontab -l 2>/dev/null; echo "0 0 * * * docker-compose -f $(pwd)/docker-compose.yml run --rm certbot renew && docker-compose -f $(pwd)/docker-compose.yml exec nginx nginx -s reload") | crontab -


            # Verify deployment
            docker ps -a
            echo "API available at http://${{ secrets.ECS_IP }}:8080"
            echo "PostgreSQL available at ${{ secrets.ECS_IP }}:5432"
            echo "Kafka available at ${{ secrets.ECS_IP }}:9092"