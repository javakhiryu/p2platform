name: Deploy to production

on:
  push:
    branches: [main]

jobs:
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create app.env file
        run: |
          cat <<EOF > app.env
          ENVIRONMENT=${{ secrets.ENVIRONMENT }}
          DB_SOURCE=postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@postgres:5432/${{ secrets.DB_NAME }}
          HTTP_SERVER_ADDRESS=${{ secrets.ECS_IP }}:8080
          KAFKA_BROKERS=kafka:9092
          TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }}
          EOF

      - name: Install swag
        run: |
          go install github.com/swaggo/swag/cmd/swag@latest
          go get -u github.com/swaggo/gin-swagger
          go get -u github.com/swaggo/files
          echo "$(go env GOPATH)/bin" >> $GITHUB_PATH

      - name: Login to Personal ACR
        uses: aliyun/acr-login@v1
        with:
          login-server: https://crpi-qzh5i8b0hkdo3v4d.ap-southeast-1.personal.cr.aliyuncs.com
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Build and push API image
        run: |
          docker build -t crpi-qzh5i8b0hkdo3v4d.ap-southeast-1.personal.cr.aliyuncs.com/p2platform/api:${{ github.sha }} .
          docker push crpi-qzh5i8b0hkdo3v4d.ap-southeast-1.personal.cr.aliyuncs.com/p2platform/api:${{ github.sha }}

      - name: Deploy to ECS
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.ECS_IP }}
          username: root
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -ex

            # Install Docker
            if ! command -v docker &>/dev/null; then
              apt-get update -qq
              apt-get install -y -qq \
                apt-transport-https \
                ca-certificates \
                curl \
                gnupg2 \
                software-properties-common

              curl -fsSL https://download.docker.com/linux/debian/gpg | apt-key add -
              add-apt-repository \
                "deb [arch=amd64] https://download.docker.com/linux/debian \
                buster \
                stable"

              apt-get update -qq
              apt-get install -y -qq docker-ce docker-ce-cli containerd.io
              systemctl enable docker
              systemctl start docker
            fi

            # Install Docker Compose
            if ! command -v docker-compose &>/dev/null; then
              curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              chmod +x /usr/local/bin/docker-compose
              ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
            fi

            # Login to ACR
            echo "${{ secrets.REGISTRY_PASSWORD }}" | \
              docker login \
                --username "${{ secrets.REGISTRY_USERNAME }}" \
                --password-stdin \
                crpi-qzh5i8b0hkdo3v4d.ap-southeast-1.personal.cr.aliyuncs.com

            # Create docker-compose.yml
            cat > docker-compose.yml <<EOF
            version: '3.8'

            networks:
              p2platform:
                driver: bridge

            volumes:
              db-data:
              kafka-data:

            services:
              postgres:
                image: postgres:17-alpine
                environment:
                  POSTGRES_USER: ${{ secrets.DB_USER }}
                  POSTGRES_PASSWORD: ${{ secrets.DB_PASSWORD }}
                  POSTGRES_DB: ${{ secrets.DB_NAME }}
                ports:
                  - "5432:5432"
                volumes:
                  - db-data:/var/lib/postgresql/data
                networks:
                  - p2platform

              api:
                image: crpi-qzh5i8b0hkdo3v4d.ap-southeast-1.personal.cr.aliyuncs.com/p2platform/api:${{ github.sha }}
                ports:
                  - "8080:8080"
                environment:
                  - DB_SOURCE=postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@postgres:5432/${{ secrets.DB_NAME }}?sslmode=disable
                  - KAFKA_BROKERS=kafka:9092
                depends_on:
                  - postgres
                  - kafka
                entrypoint: ["/app/wait-for.sh", "postgres:5432", "--", "/app/start.sh"]
                command: ["/app/main"]
                networks:
                  - p2platform

              kafka:
                image: bitnami/kafka:latest
                networks:
                  - p2platform
                environment:
                  - KAFKA_HEAP_OPTS=-Xmx512m -Xms256m
                  - KAFKA_CFG_NODE_ID=0
                  - KAFKA_CFG_PROCESS_ROLES=controller,broker
                  - KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093
                  - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT
                  - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=0@kafka:9093
                  - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER
                ports:
                  - "9092:9092"
                volumes:
                  - kafka-data:/bitnami/kafka
            EOF

            # Deploy services
            docker-compose pull
            docker-compose down || true
            docker-compose up -d

            # Verify deployment
            docker ps -a
            echo "API available at http://${{ secrets.ECS_IP }}:8080"
            echo "PostgreSQL available at ${{ secrets.ECS_IP }}:5432"
            echo "Kafka available at ${{ secrets.ECS_IP }}:9092"
